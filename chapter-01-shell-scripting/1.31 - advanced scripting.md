# 1.31 - Advanced Scripting
##### LPIC-1: Linux Administrator (102-500)

## Learning Objectives

At the end of this lesson, you will be able to:

1. **Master** advanced programming constructs in bash scripts
2. **Implement** complex loops, conditionals, and logic structures
3. **Create** robust user account management scripts
4. **Apply** error handling and validation techniques
5. **Develop** modular, maintainable scripts for system administration

---

## Advanced Programming Constructs

Advanced scripting goes beyond basic commands to include sophisticated logic, error handling, and automation patterns used in professional system administration.

### Key Programming Elements

- **Loops**: Repetitive execution with various patterns
- **Conditionals**: Complex decision-making logic
- **Functions**: Reusable code blocks
- **Error Handling**: Robust failure management
- **Validation**: Input and process verification
- **Modularity**: Organized, maintainable code structure

---

## Advanced Loop Techniques

### Multiple Loop Solutions

Let's explore different approaches to the same problem: creating numbered files.

#### Solution 1: For Loop with seq

```bash
#!/bin/bash
# Create 10 video files using for loop with seq
# This approach is clean and readable

echo "Creating video files using for loop..."

for filenum in $(seq 1 10); do
    # Create each file with descriptive output
    touch "video${filenum}.mp4"
    echo "Created: video${filenum}.mp4"
done

echo "All files created successfully!"
```

#### Solution 2: While Loop with Countdown

```bash
#!/bin/bash
# Create 10 video files using while loop (countdown approach)
# This approach gives more control over the loop counter

echo "Creating video files using while loop..."

filenum=10  # Start from 10 and count down

while [ $filenum -gt 0 ]; do
    # Create file and display progress
    touch "video${filenum}.mp4"
    echo "Created: video${filenum}.mp4 (${filenum} remaining)"
    
    # Decrement counter (multiple syntax options)
    filenum=$((filenum - 1))    # Arithmetic expansion
    # Alternative: filenum=`expr $filenum - 1`  # Using expr command
done

echo "All files created successfully!"
```

#### Solution 3: Enhanced Loop with Validation

```bash
#!/bin/bash
# Advanced file creation with error checking and options

echo "=== Advanced Video File Creator ==="

# Configuration variables
DEFAULT_COUNT=10
DEFAULT_PREFIX="video"
DEFAULT_EXTENSION="mp4"

# Get user input with defaults
read -p "Number of files [$DEFAULT_COUNT]: " file_count
read -p "File prefix [$DEFAULT_PREFIX]: " file_prefix
read -p "File extension [$DEFAULT_EXTENSION]: " file_ext

# Use defaults if empty
file_count=${file_count:-$DEFAULT_COUNT}
file_prefix=${file_prefix:-$DEFAULT_PREFIX}
file_ext=${file_ext:-$DEFAULT_EXTENSION}

# Validate numeric input
if ! [[ "$file_count" =~ ^[0-9]+$ ]] || [ "$file_count" -le 0 ]; then
    echo "Error: File count must be a positive number"
    exit 1
fi

echo "Creating $file_count files with pattern: ${file_prefix}#.${file_ext}"

# Advanced for loop with error handling
for ((i=1; i<=file_count; i++)); do
    filename="${file_prefix}${i}.${file_ext}"
    
    # Check if file already exists
    if [ -f "$filename" ]; then
        echo "Warning: $filename already exists, skipping..."
        continue
    fi
    
    # Create file with error checking
    if touch "$filename" 2>/dev/null; then
        echo "✓ Created: $filename"
    else
        echo "✗ Failed to create: $filename"
    fi
done

echo "File creation process completed!"
```

### Advanced Loop Patterns

```bash
#!/bin/bash
# Various advanced loop patterns

# 1. Loop with break and continue
echo "=== Loop Control Demo ==="
for i in $(seq 1 20); do
    # Skip even numbers
    if [ $((i % 2)) -eq 0 ]; then
        continue
    fi
    
    echo "Processing odd number: $i"
    
    # Stop at 15
    if [ $i -ge 15 ]; then
        echo "Stopping at $i"
        break
    fi
done

# 2. Nested loops
echo -e "\n=== Multiplication Table ==="
for i in $(seq 1 5); do
    for j in $(seq 1 5); do
        result=$((i * j))
        printf "%2d " $result
    done
    echo  # New line after each row
done

# 3. Loop through arrays
echo -e "\n=== Array Processing ==="
servers=("web01" "web02" "db01" "cache01")
for server in "${servers[@]}"; do
    echo "Checking server: $server"
    # Simulate server check
    if ping -c 1 "$server" &>/dev/null; then
        echo "  ✓ $server is reachable"
    else
        echo "  ✗ $server is unreachable"
    fi
done

# 4. While loop reading from file
echo -e "\n=== File Processing ==="
if [ -f "/etc/passwd" ]; then
    line_num=0
    while IFS=: read -r username password uid gid gecos home shell; do
        line_num=$((line_num + 1))
        
        # Process only first 5 users
        if [ $line_num -gt 5 ]; then
            break
        fi
        
        echo "User $line_num: $username (UID: $uid, Home: $home)"
    done < /etc/passwd
fi
```

---

## Advanced Conditional Logic

### Complex If/Then/Else Structures

```bash
#!/bin/bash
# Advanced conditional logic examples

# 1. Multiple condition testing
check_system_resources() {
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    local memory_usage=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100}')
    local disk_usage=$(df / | tail -1 | awk '{print $5}' | cut -d'%' -f1)
    
    echo "=== System Resource Check ==="
    echo "CPU Usage: ${cpu_usage}%"
    echo "Memory Usage: ${memory_usage}%"
    echo "Disk Usage: ${disk_usage}%"
    
    # Complex conditional logic
    if [ "${cpu_usage%.*}" -gt 80 ] && [ "$memory_usage" -gt 90 ]; then
        echo "CRITICAL: High CPU and Memory usage!"
        return 2
    elif [ "${cpu_usage%.*}" -gt 80 ] || [ "$memory_usage" -gt 90 ] || [ "$disk_usage" -gt 85 ]; then
        echo "WARNING: High resource usage detected"
        return 1
    else
        echo "OK: System resources normal"
        return 0
    fi
}

# 2. Case statement for menu systems
show_admin_menu() {
    while true; do
        echo
        echo "=== System Administration Menu ==="
        echo "1. User Management"
        echo "2. System Monitoring"
        echo "3. File Operations"
        echo "4. Network Tools"
        echo "5. Exit"
        
        read -p "Select option (1-5): " choice
        
        case $choice in
            1)
                echo "User Management selected"
                # Call user management function
                ;;
            2)
                echo "System Monitoring selected"
                check_system_resources
                ;;
            3)
                echo "File Operations selected"
                # Call file operations function
                ;;
            4)
                echo "Network Tools selected"
                # Call network tools function
                ;;
            5)
                echo "Exiting..."
                break
                ;;
            *)
                echo "Invalid option. Please try again."
                ;;
        esac
        
        read -p "Press Enter to continue..."
    done
}

# 3. Advanced string and file testing
validate_input() {
    local input="$1"
    local type="$2"
    
    case $type in
        "email")
            if [[ "$input" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
                return 0
            else
                echo "Invalid email format"
                return 1
            fi
            ;;
        "username")
            if [[ "$input" =~ ^[a-z][a-z0-9_-]{2,15}$ ]]; then
                return 0
            else
                echo "Username must start with lowercase letter, 3-16 chars, lowercase/numbers/underscore/dash only"
                return 1
            fi
            ;;
        "number")
            if [[ "$input" =~ ^[0-9]+$ ]] && [ "$input" -gt 0 ]; then
                return 0
            else
                echo "Must be a positive number"
                return 1
            fi
            ;;
        *)
            echo "Unknown validation type"
            return 1
            ;;
    esac
}
```

---

## User Account Management Scripts

### Basic User Creation (No Validation)

```bash
#!/bin/bash
# Basic user creation script (demonstrates problems without validation)
# WARNING: This script has security and logic issues

echo "=== Basic User Creation (Unsafe) ==="

echo -n "Username: "
read username
echo -n "Full Name: "
read fullname
echo -n "Password: "
read password

# Problem: No validation, password in command history, etc.
useradd -c "$fullname" "$username" -p "$password"

echo "User creation attempted (may have failed)"
```

### Improved User Creation with Basic Validation

```bash
#!/bin/bash
# Improved user creation with basic existence check

echo "=== User Creation with Basic Validation ==="

echo -n "Username: "
read username

# Check if user already exists
if id "$username" &>/dev/null; then
    echo "Error: Username '$username' already exists"
    exit 1
else
    echo -n "Full Name: "
    read fullname
    echo -n "Password: "
    read -s password  # Silent password input
    echo  # New line after password
    
    # Create user account
    if useradd -c "$fullname" "$username"; then
        echo "User created successfully"
        
        # Set password securely
        echo "$username:$password" | chpasswd
        
        # Verify creation
        if id "$username" &>/dev/null; then
            echo "✓ User account verified"
        else
            echo "✗ User verification failed"
        fi
    else
        echo "✗ Failed to create user account"
    fi
fi
```

### Advanced User Creation with Full Validation

```bash
#!/bin/bash
# Advanced user creation script with comprehensive validation

echo "=== Advanced User Account Creator ==="

# Configuration
MIN_USERNAME_LENGTH=3
MAX_USERNAME_LENGTH=16
MIN_PASSWORD_LENGTH=8

# Function to validate username
validate_username() {
    local username="$1"
    
    # Check length
    if [ ${#username} -lt $MIN_USERNAME_LENGTH ] || [ ${#username} -gt $MAX_USERNAME_LENGTH ]; then
        echo "Username must be $MIN_USERNAME_LENGTH-$MAX_USERNAME_LENGTH characters"
        return 1
    fi
    
    # Check format (alphanumeric, underscore, dash, must start with letter)
    if ! [[ "$username" =~ ^[a-z][a-z0-9_-]*$ ]]; then
        echo "Username must start with lowercase letter, contain only lowercase letters, numbers, underscore, or dash"
        return 1
    fi
    
    # Check if user exists
    if id "$username" &>/dev/null; then
        echo "Username '$username' already exists"
        return 1
    fi
    
    # Check if username is reserved
    local reserved_users=("root" "daemon" "bin" "sys" "sync" "games" "man" "lp" "mail" "news" "uucp" "proxy" "www-data" "backup" "list" "irc" "gnats" "nobody")
    for reserved in "${reserved_users[@]}"; do
        if [ "$username" = "$reserved" ]; then
            echo "Username '$username' is reserved"
            return 1
        fi
    done
    
    return 0
}

# Function to validate password strength
validate_password() {
    local password="$1"
    
    # Check minimum length
    if [ ${#password} -lt $MIN_PASSWORD_LENGTH ]; then
        echo "Password must be at least $MIN_PASSWORD_LENGTH characters"
        return 1
    fi
    
    # Check for at least one uppercase letter
    if ! [[ "$password" =~ [A-Z] ]]; then
        echo "Password must contain at least one uppercase letter"
        return 1
    fi
    
    # Check for at least one lowercase letter
    if ! [[ "$password" =~ [a-z] ]]; then
        echo "Password must contain at least one lowercase letter"
        return 1
    fi
    
    # Check for at least one number
    if ! [[ "$password" =~ [0-9] ]]; then
        echo "Password must contain at least one number"
        return 1
    fi
    
    # Check for at least one special character
    if ! [[ "$password" =~ [^a-zA-Z0-9] ]]; then
        echo "Password must contain at least one special character"
        return 1
    fi
    
    return 0
}

# Function to get and validate username
get_username() {
    while true; do
        read -p "Username: " username
        
        if [ -z "$username" ]; then
            echo "Username cannot be empty"
            continue
        fi
        
        if validate_username "$username"; then
            echo "✓ Username '$username' is valid"
            break
        fi
    done
}

# Function to get and validate full name
get_fullname() {
    while true; do
        read -p "Full Name: " fullname
        
        if [ -z "$fullname" ]; then
            echo "Full name cannot be empty"
            continue
        fi
        
        if [[ "$fullname" =~ ^[a-zA-Z[:space:].'-]+$ ]]; then
            echo "✓ Full name is valid"
            break
        else
            echo "Full name can only contain letters, spaces, periods, apostrophes, and hyphens"
        fi
    done
}

# Function to get and validate password
get_password() {
    while true; do
        read -s -p "Password: " password
        echo
        
        if [ -z "$password" ]; then
            echo "Password cannot be empty"
            continue
        fi
        
        if validate_password "$password"; then
            read -s -p "Confirm password: " password_confirm
            echo
            
            if [ "$password" = "$password_confirm" ]; then
                echo "✓ Password confirmed"
                break
            else
                echo "Passwords do not match"
            fi
        fi
    done
}

# Function to create user account
create_user_account() {
    echo
    echo "Creating user account..."
    
    # Create user with home directory
    if useradd -m -c "$fullname" -s "/bin/bash" "$username"; then
        echo "✓ User account created"
        
        # Set password securely
        if echo "$username:$password" | chpasswd; then
            echo "✓ Password set successfully"
        else
            echo "✗ Failed to set password"
            return 1
        fi
        
        # Set password expiry policy
        if chage -d 0 "$username" 2>/dev/null; then
            echo "✓ Password expiry policy set (user must change on first login)"
        fi
        
        # Verify account creation
        if id "$username" &>/dev/null && [ -d "/home/$username" ]; then
            echo "✓ User account verification successful"
            
            # Display account information
            echo
            echo "=== Account Summary ==="
            echo "Username: $username"
            echo "Full Name: $fullname"
            echo "Home Directory: /home/$username"
            echo "Shell: /bin/bash"
            echo "UID: $(id -u "$username")"
            echo "GID: $(id -g "$username")"
            
            return 0
        else
            echo "✗ User account verification failed"
            return 1
        fi
    else
        echo "✗ Failed to create user account"
        return 1
    fi
}

# Main script execution
echo "This script will create a new user account with full validation."
echo "You must have sudo privileges to create user accounts."
echo

# Check if running as root or with sudo
if [ "$EUID" -ne 0 ]; then
    echo "This script must be run as root or with sudo privileges"
    echo "Usage: sudo $0"
    exit 1
fi

# Get user input
get_username
get_fullname
get_password

# Confirmation
echo
echo "=== Account Creation Summary ==="
echo "Username: $username"
echo "Full Name: $fullname"
echo "Password: [HIDDEN]"
echo

read -p "Create this user account? (y/N): " confirm

if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
    create_user_account
    
    if [ $? -eq 0 ]; then
        echo
        echo "🎉 User account created successfully!"
        echo "The user can now log in with username: $username"
    else
        echo
        echo "❌ User account creation failed!"
        exit 1
    fi
else
    echo "User account creation cancelled"
    exit 0
fi
```

---

## Functions and Modular Programming

### Creating Reusable Functions

```bash
#!/bin/bash
# Advanced scripting with functions

# Function library for system administration

# Function to log messages with timestamps
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        "INFO")  echo "[$timestamp] INFO: $message" ;;
        "WARN")  echo "[$timestamp] WARN: $message" >&2 ;;
        "ERROR") echo "[$timestamp] ERROR: $message" >&2 ;;
        "DEBUG") 
            if [ "$DEBUG" = "true" ]; then
                echo "[$timestamp] DEBUG: $message"
            fi
            ;;
        *) echo "[$timestamp] $message" ;;
    esac
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to check system requirements
check_requirements() {
    log_message "INFO" "Checking system requirements..."
    
    local required_commands=("useradd" "usermod" "userdel" "chage" "passwd")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "$cmd"; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [ ${#missing_commands[@]} -gt 0 ]; then
        log_message "ERROR" "Missing required commands: ${missing_commands[*]}"
        return 1
    fi
    
    log_message "INFO" "All required commands available"
    return 0
}

# Function to backup user data
backup_user_data() {
    local username="$1"
    local backup_dir="/tmp/user_backups"
    
    if [ -z "$username" ]; then
        log_message "ERROR" "Username required for backup"
        return 1
    fi
    
    if ! id "$username" &>/dev/null; then
        log_message "ERROR" "User '$username' does not exist"
        return 1
    fi
    
    mkdir -p "$backup_dir"
    local backup_file="$backup_dir/${username}_$(date +%Y%m%d_%H%M%S).tar.gz"
    
    log_message "INFO" "Creating backup for user: $username"
    
    if tar -czf "$backup_file" -C /home "$username" 2>/dev/null; then
        log_message "INFO" "Backup created: $backup_file"
        return 0
    else
        log_message "ERROR" "Failed to create backup for user: $username"
        return 1
    fi
}

# Function to generate secure random password
generate_password() {
    local length="${1:-12}"
    
    # Use /dev/urandom to generate random password
    if command_exists "openssl"; then
        openssl rand -base64 32 | tr -d "=+/" | cut -c1-$length
    elif [ -c /dev/urandom ]; then
        tr -dc 'A-Za-z0-9!@#$%^&*' < /dev/urandom | head -c $length
    else
        # Fallback method
        date +%s | sha256sum | base64 | head -c $length
    fi
}

# Function to display user information
show_user_info() {
    local username="$1"
    
    if ! id "$username" &>/dev/null; then
        log_message "ERROR" "User '$username' does not exist"
        return 1
    fi
    
    echo "=== User Information: $username ==="
    
    # Basic user info
    local user_info=$(getent passwd "$username")
    IFS=':' read -r user_name x uid gid gecos home_dir shell <<< "$user_info"
    
    echo "Username: $user_name"
    echo "UID: $uid"
    echo "GID: $gid"
    echo "Full Name: ${gecos:-"Not specified"}"
    echo "Home Directory: $home_dir"
    echo "Shell: $shell"
    
    # Account status
    local account_status=$(passwd -S "$username" 2>/dev/null | awk '{print $2}')
    echo "Account Status: $account_status"
    
    # Group memberships
    echo "Groups: $(groups "$username" | cut -d: -f2)"
    
    # Last login
    local last_login=$(last -1 "$username" 2>/dev/null | head -1)
    echo "Last Login: $last_login"
    
    # Home directory info
    if [ -d "$home_dir" ]; then
        echo "Home Directory Size: $(du -sh "$home_dir" 2>/dev/null | cut -f1)"
        echo "Home Directory Permissions: $(stat -c%A "$home_dir" 2>/dev/null)"
    else
        echo "Home Directory: Missing"
    fi
}

# Main function demonstrating modular approach
main() {
    log_message "INFO" "Starting advanced user management script"
    
    # Check requirements
    if ! check_requirements; then
        log_message "ERROR" "System requirements not met"
        exit 1
    fi
    
    # Example usage of functions
    while true; do
        echo
        echo "=== Advanced User Management ==="
        echo "1. Show user information"
        echo "2. Generate secure password"
        echo "3. Backup user data"
        echo "4. Exit"
        
        read -p "Select option (1-4): " choice
        
        case $choice in
            1)
                read -p "Enter username: " username
                show_user_info "$username"
                ;;
            2)
                read -p "Password length [12]: " length
                length=${length:-12}
                password=$(generate_password "$length")
                echo "Generated password: $password"
                ;;
            3)
                read -p "Enter username to backup: " username
                backup_user_data "$username"
                ;;
            4)
                log_message "INFO" "Exiting script"
                exit 0
                ;;
            *)
                log_message "WARN" "Invalid option selected"
                ;;
        esac
    done
}

# Run main function if script is executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
```

---

## Error Handling and Debugging

### Advanced Error Handling Patterns

```bash
#!/bin/bash
# Advanced error handling and debugging techniques

# Set strict mode
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Global error tracking
declare -g SCRIPT_ERRORS=0
declare -g LOG_FILE="/tmp/script_$(date +%Y%m%d_%H%M%S).log"

# Error handler function
error_handler() {
    local line_number=$1
    local command="$2"
    local error_code=$3
    
    echo "ERROR: Command '$command' failed with exit code $error_code at line $line_number" >&2
    echo "ERROR: Command '$command' failed with exit code $error_code at line $line_number" >> "$LOG_FILE"
    
    SCRIPT_ERRORS=$((SCRIPT_ERRORS + 1))
    
    # Optionally show stack trace
    if [ "$DEBUG" = "true" ]; then
        echo "Call stack:" >&2
        local frame=0
        while caller $frame; do
            ((frame++))
        done
    fi
}

# Set error trap
trap 'error_handler ${LINENO} "$BASH_COMMAND" $?' ERR

# Function with error handling
safe_command() {
    local command="$1"
    local description="$2"
    
    echo "Executing: $description"
    
    if eval "$command"; then
        echo "✓ Success: $description"
        return 0
    else
        local exit_code=$?
        echo "✗ Failed: $description (exit code: $exit_code)" >&2
        return $exit_code
    fi
}

# Function to validate and execute with retry
execute_with_retry() {
    local max_attempts=3
    local delay=1
    local command="$1"
    local description="$2"
    
    for ((attempt=1; attempt<=max_attempts; attempt++)); do
        echo "Attempt $attempt/$max_attempts: $description"
        
        if eval "$command"; then
            echo "✓ Success on attempt $attempt"
            return 0
        else
            local exit_code=$?
            echo "✗ Failed on attempt $attempt (exit code: $exit_code)"
            
            if [ $attempt -lt $max_attempts ]; then
                echo "Retrying in $delay seconds..."
                sleep $delay
                delay=$((delay * 2))  # Exponential backoff
            fi
        fi
    done
    
    echo "✗ All attempts failed for: $description" >&2
    return 1
}
```

---

## Best Practices Summary

### Script Organization

```bash
#!/bin/bash
# Template for well-organized advanced scripts

# Script metadata
readonly SCRIPT_NAME="Advanced User Management"
readonly SCRIPT_VERSION="2.0"
readonly SCRIPT_AUTHOR="System Administrator"
readonly SCRIPT_DESC="Comprehensive user account management with validation"

# Configuration
readonly CONFIG_FILE="/etc/user-manager.conf"
readonly LOG_DIR="/var/log/user-manager"
readonly BACKUP_DIR="/var/backups/users"

# Global variables
declare -g DEBUG="${DEBUG:-false}"
declare -g VERBOSE="${VERBOSE:-false}"
declare -g DRY_RUN="${DRY_RUN:-false}"

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Usage function
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS] COMMAND [ARGS]

DESCRIPTION:
    $SCRIPT_DESC

OPTIONS:
    -h, --help      Show this help message
    -v, --verbose   Enable verbose output
    -d, --debug     Enable debug mode
    -n, --dry-run   Show what would be done without executing
    --version       Show script version

COMMANDS:
    create          Create new user account
    delete          Delete user account
    modify          Modify existing user account
    info            Show user information
    list            List all users

EXAMPLES:
    $0 create
    $0 info username
    $0 --verbose list
    $0 --dry-run delete username

EOF
}

# Cleanup function
cleanup() {
    local exit_code=$?
    
    # Perform cleanup tasks
    if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
    
    # Log script completion
    log_message "INFO" "Script completed with exit code: $exit_code"
    
    exit $exit_code
}

# Set cleanup trap
trap cleanup EXIT

# Main script structure
main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Initialize script environment
    initialize_environment
    
    # Execute requested command
    execute_command "$@"
}

# Run main function if script is executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
```

---

## Summary

**Advanced concepts covered:**
- **Complex loops**: Multiple approaches, nested loops, advanced patterns
- **Conditional logic**: Multi-condition testing, case statements, validation
- **User management**: Comprehensive account creation with full validation
- **Functions**: Modular programming, reusable components
- **Error handling**: Robust failure management, retry mechanisms
- **Best practices**: Script organization, documentation, maintainability

**Key takeaways:**
- Always validate input before processing
- Use functions for reusable code
- Implement proper error handling
- Log activities for debugging
- Test scripts thoroughly before deployment
- Follow consistent coding standards

## Next Steps

Practice these advanced concepts in the accompanying lab to master professional-level script development.